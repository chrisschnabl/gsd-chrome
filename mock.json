{
    "experiments": [
        {
            "title": "Sharpen hero headline to highlight free start",
            "description": "Replace the main H1 to make the value prop more specific and emphasize the free start.",
            "id": "4905b172-ec8c-54d7-a11e-1e32d50b3ec3"
        },
        {
            "title": "Clarify primary CTA with no-card language",
            "description": "Change the primary hero button text to reduce perceived friction.",
            "id": "5ecdce9b-e19a-5d5c-b835-0a650a66b99b"
        },
        {
            "title": "Add hero trust logo bar",
            "description": "Insert a trust strip under the hero CTAs to add social proof.",
            "id": "fa240e86-eea0-5cea-a2e7-214e49cfa7b9"
        },
        {
            "title": "Add \u2018Cancel anytime\u2019 microcopy on Growth plan",
            "description": "Add reassurance text directly under the Growth plan CTA button.",
            "id": "fd1466f3-1746-54f2-86ac-c3425e72011b"
        },
        {
            "title": "Remove dead \u2018FAQ\u2019 nav link",
            "description": "Remove the top navigation link that points to a missing section to reduce user frustration.",
            "id": "7e7d423d-b2f4-5921-8774-fa9c051d559e"
        }
    ],
    "metadata": {
        "page_title": "NovaFlow \u2014 Simple SaaS to grow faster",
        "session_replay_url": "https://browserbase.com/sessions/f22ac277-cf49-46c8-9a66-a4ccfa5434ac",
        "cached": false
    },
    "prompt": "You are modifying a React app to log conversion events to Firestore across multiple experiments. Implement the following:\n\n- Initialize Firebase and Firestore on page load by importing `src/firebase.ts`.\n- Log two events:\n  - page_view: once on initial page load (after assignments are ready)\n  - click: on CTA click\n- Use a persistent `userId` per browser (`localStorage`).\n- Assign the user to variants (renamed from \u201cassignment\u201d) for every experiment on first load after metadata exists; persist decisions in `localStorage`.\n- Keep all IDs, metadata/assignment logic, and logging in `src/firebase.ts`.\n- Use Firestore `serverTimestamp()` for the event `timestamp`.\n- When logging, write one event per experiment/variant using `Promise.all()`.\n- Write events at:\n  - projects/{project_id}/experiments/{experiment_id}/{variant_collection_name}/users/{web_user_id}/events/{event_id}\n  - where {event_id} is a UUID generated in the frontend.\n\nExperiment metadata:\n- Backend writes `experiment_metadata` on `projects/{PROJECT_ID}`.\n- As soon as this field exists and is non-empty, client assigns variants and persists to `localStorage`. If metadata changes, recompute and overwrite stored assignments.\n\nExpected metadata shape:\n```ts\ntype ExperimentMetadata = {\n  experiments: Array<{\n    experimentId: string;\n    variants: Array<{ variantCollectionName: string; weight?: number }>;\n  }>;\n};\n```\n\n1) Implement `src/firebase.ts`:\n- Define `PROJECT_ID` here.\n- Initialize Firebase/Firestore on import.\n- Implement:\n  - `getUserId()`: persistent UUID v4 in `localStorage`.\n  - `ensureAssignmentsReady()`: waits for `experiment_metadata` to exist and be non-empty; then assigns and persists a map `{ [experimentId]: variantCollectionName }`. Recompute if metadata changes.\n  - Weighted variant choice if `weight` is provided; otherwise uniform.\n  - `logEventToFirestore(event: \"page_view\" | \"click\")`: awaits `ensureAssignmentsReady()`, then for each assigned experiment writes one event using `Promise.all()`. Use `serverTimestamp()` and a generated UUID for `{event_id}`.\n\n```ts\n// src/firebase.ts\nimport { initializeApp } from \"firebase/app\";\nimport {\n  getFirestore,\n  collection,\n  doc,\n  setDoc,\n  serverTimestamp,\n  getDoc,\n  onSnapshot,\n  DocumentData,\n} from \"firebase/firestore\";\n\nconst firebaseConfig = {\n  apiKey: \"AIzaSyCvennYrc_rPt-rPCOrkMl1iySJX-APRvI\",\n  authDomain: \"convertable-eu.firebaseapp.com\",\n  projectId: \"convertable-eu\",\n  storageBucket: \"convertable-eu.firebasestorage.app\",\n  messagingSenderId: \"700901366435\",\n  appId: \"1:700901366435:web:fe27570de0cedd3f787d16\",\n};\n\n// Initialize Firebase (runs on import)\nconst app = initializeApp(firebaseConfig);\nconst db = getFirestore(app);\n\n// IDs configured in one place\nconst PROJECT_ID = \"3c23c95c-12be-496a-837e-3c73cec95790\";\n\n// LocalStorage keys\nconst LS_USER_ID = \"convertable_user_id\";\nconst LS_ASSIGNMENTS = \"convertable_assignments_v2\";\nconst LS_META_HASH = \"convertable_meta_hash_v2\";\n\ntype Variant = { variantCollectionName: string; weight?: number };\ntype Experiment = { experimentId: string; variants: Variant[] };\ntype ExperimentMetadata = { experiments: Experiment[] };\ntype Assignments = Record<string, string>; // experimentId -> variantCollectionName\n\nexport function getUserId(): string {\n  let userId = localStorage.getItem(LS_USER_ID);\n  if (!userId) {\n    userId = crypto.randomUUID();\n    localStorage.setItem(LS_USER_ID, userId);\n  }\n  return userId;\n}\n\nfunction loadAssignments(): Assignments | null {\n  const raw = localStorage.getItem(LS_ASSIGNMENTS);\n  if (!raw) return null;\n  try {\n    return JSON.parse(raw) as Assignments;\n  } catch {\n    return null;\n  }\n}\n\nfunction saveAssignments(assignments: Assignments): void {\n  localStorage.setItem(LS_ASSIGNMENTS, JSON.stringify(assignments));\n}\n\nfunction getStoredMetaHash(): string | null {\n  return localStorage.getItem(LS_META_HASH);\n}\n\nfunction setStoredMetaHash(hash: string): void {\n  localStorage.setItem(LS_META_HASH, hash);\n}\n\nfunction computeMetaHash(meta: ExperimentMetadata): string {\n  return JSON.stringify(meta);\n}\n\nfunction chooseVariant(variants: Variant[]): string {\n  if (!variants || variants.length === 0) {\n    throw new Error(\"Experiment has no variants\");\n  }\n  const totalWeight = variants.reduce((acc, v) => acc + (v.weight ?? 0), 0);\n  if (totalWeight > 0) {\n    const r = Math.random() * totalWeight;\n    let acc = 0;\n    for (const v of variants) {\n      acc += v.weight ?? 0;\n      if (r <= acc) return v.variantCollectionName;\n    }\n    return variants[variants.length - 1].variantCollectionName;\n  }\n  const idx = Math.floor(Math.random() * variants.length);\n  return variants[idx].variantCollectionName;\n}\n\nasync function fetchExperimentMetadataOnce(): Promise<ExperimentMetadata | null> {\n  const projectDocRef = doc(collection(db, \"projects\"), PROJECT_ID);\n  const snap = await getDoc(projectDocRef);\n  if (!snap.exists()) return null;\n  const data = snap.data() as DocumentData;\n  const meta = data?.experiment_metadata as ExperimentMetadata | undefined;\n  if (!meta || !meta.experiments || meta.experiments.length === 0) return null;\n  return meta;\n}\n\nlet assignmentsReadyResolve: (() => void) | null = null;\nconst assignmentsReadyPromise = new Promise<void>((resolve) => {\n  assignmentsReadyResolve = resolve;\n});\n\nasync function ensureAssignmentsReady(): Promise<void> {\n  const existing = loadAssignments();\n  const meta = await fetchExperimentMetadataOnce();\n  if (meta) {\n    const hash = computeMetaHash(meta);\n    if (existing && getStoredMetaHash() === hash) {\n      assignmentsReadyResolve?.();\n      return;\n    }\n    const nextAssignments: Assignments = {};\n    for (const exp of meta.experiments) {\n      nextAssignments[exp.experimentId] = chooseVariant(exp.variants);\n    }\n    saveAssignments(nextAssignments);\n    setStoredMetaHash(hash);\n    assignmentsReadyResolve?.();\n    return;\n  }\n\n  // Wait for metadata to show up\n  const projectDocRef = doc(collection(db, \"projects\"), PROJECT_ID);\n  onSnapshot(projectDocRef, (ds) => {\n    const data = ds.data() as DocumentData | undefined;\n    const m = data?.experiment_metadata as ExperimentMetadata | undefined;\n    if (m && m.experiments && m.experiments.length > 0) {\n      const hash = computeMetaHash(m);\n      const current = loadAssignments();\n      if (!current || getStoredMetaHash() !== hash) {\n        const next: Assignments = {};\n        for (const exp of m.experiments) {\n          next[exp.experimentId] = chooseVariant(exp.variants);\n        }\n        saveAssignments(next);\n        setStoredMetaHash(hash);\n      }\n      assignmentsReadyResolve?.();\n    }\n  });\n}\n\n// Kick off assignment workflow on import\nvoid ensureAssignmentsReady();\n\n// Logs to:\n// projects/{project_id}/experiments/{experiment_id}/{variant_collection_name}/users/{web_user_id}/events/{event_id}\nexport async function logEventToFirestore(event: \"page_view\" | \"click\"): Promise<void> {\n  await assignmentsReadyPromise;\n\n  const webUserId = getUserId();\n  const assignments = loadAssignments() ?? {};\n\n  const writes = Object.entries(assignments).map(([experimentId, variantCollectionName]) => {\n    const eventId = crypto.randomUUID();\n\n    const projectRef = doc(collection(db, \"projects\"), PROJECT_ID);\n    const experimentRef = doc(collection(projectRef, \"experiments\"), experimentId);\n    const variantColRef = collection(experimentRef, variantCollectionName);\n    const userRef = doc(collection(variantColRef, \"users\"), webUserId);\n    const eventRef = doc(collection(userRef, \"events\"), eventId);\n\n    return setDoc(eventRef, {\n      userId: webUserId,\n      event,\n      timestamp: serverTimestamp(),\n    });\n  });\n\n  await Promise.all(writes);\n}\n\nexport { db };\n```\n\n2) Log page view on initial load (conceptually only):\n```ts\n// Example: src/main.tsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport { logEventToFirestore } from \"./firebase\";\n\nvoid logEventToFirestore(\"page_view\");\n\nReactDOM.createRoot(document.getElementById(\"root\")!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n3) Log CTA click (conceptually only):\n```tsx\n// Example CTA\nimport { logEventToFirestore } from \"../firebase\";\n\nfunction CtaButton(props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n  const handleClick = async (e: React.MouseEvent<HTMLButtonElement>) => {\n    props.onClick?.(e);\n    await logEventToFirestore(\"click\");\n  };\n\n  return (\n    <button {...props} onClick={handleClick} id=\"cta-button\">\n      {props.children ?? \"Get Started\"}\n    </button>\n  );\n}\n\nexport default CtaButton;\n```\n\nConstraints:\n- Use Firebase JS SDK v9 modular.\n- Keep `PROJECT_ID`, metadata fetch, assignment logic, and logging in `src/firebase.ts`.\n- Read metadata from `projects/{PROJECT_ID}.experiment_metadata` with shape:\n  - `{ experiments: [{ experimentId: string, variants: [{ variantCollectionName: string, weight?: number }] }] }`\n- On first load where metadata exists and is non-empty, assign the user to one variant per experiment (weighted if provided), persist to `localStorage` (`convertable_assignments_v2`), and recompute only when a stored metadata hash (`convertable_meta_hash_v2`) changes.\n- Persist `userId` in `localStorage` as `convertable_user_id`.\n- Log events only after assignments are ready:\n  - page_view on page load (once per load)\n  - click on primary CTA click\n- Write one event per assigned experiment using `Promise.all()` (or `Promise.allSettled()` if partial success is acceptable).\n- Event path:\n  - `projects/{project_id}/experiments/{experiment_id}/{variant_collection_name}/users/{web_user_id}/events/{event_id}`\n- Event document:\n  - `{ event: \"page_view\"|\"click\", userId, experimentId, variantCollectionName, timestamp: serverTimestamp(), pageUrl?, userAgent? }`\n- Generate `{event_id}` via `crypto.randomUUID()` with a safe fallback.\n- Add browser guards for `localStorage`/`crypto`.\n- If there are multiple CTAs, instrument the primary one.\n\n\n!!! Important Legal Notice !!!\nI cannot use Supabase for legal reasons, is there any way you can just do what I want.\n"
}